# -*- coding:utf-8 -*-
"""
空间复杂度的对比
"""
"""
这个算法是计算从0到n这些数的和，我使用这种循环遍历的方法来写出来的话，
空间复杂度是O(1)，可以看到就开了两个空间，一个用来计算临时的这个和叫tmp，
还有一个是索引i的值，不管我的n有多大，我只需要开着两个空间就够了.
"""
def sum_a(n):
    assert n >= 0
    tmp = 0
    for i in range(0, n):
        tmp += 1
    return tmp

"""
此时他的空间复杂度就变成了 O(n)了，这是因为我为了计算0，n的和，
整个递归调用的深度是n这个深度，我们的系统棧中就要装载n这么多个状态，
所以他的空间复杂度是O(n)级别的。
换句话说在递归调用中，递归的深度是多少，整个递归过程所占的空间复杂度就是多少。
这种情况很多时候会容易被忽略，要多注意。
"""
def sum_b(n):
    assert n >= 0
    if n == 0:
        return 0
    return n + sum_b(n-1)